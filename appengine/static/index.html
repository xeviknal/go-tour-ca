<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Un tour per Go en català</title>

<!-- jQuery -->
<script src="static/jquery.js"></script>

<!-- CodeMirror -->
<link rel="stylesheet" href="/static/codemirror/lib/codemirror.css">
<script src="/static/codemirror/lib/codemirror.js"></script>
<script src="/static/codemirror/lib/go.js"></script>

<!-- Tour -->
<link rel="stylesheet" href="static/tour.css">
<script src="static/mode.js"></script>
<script>
// Localized user interface.
var tr = {
	"off": "no",
	"on": "sí",
	"syntax": "Ressaltar sintaxi",
	"lineno": "Nombre de línia",
	"reset": "Restaurar",
	"format": "Donar format al codi",
	"kill": "Acabar execució",
	"run": "Executar",
	"toc": "Taula de continguts",
	"prev": "Anterior",
	"next": "Següent",
	"waiting": "Esperant el servidor remot...",
	"errcomm": "Error de comunicació amb el servidor remot.",
}
</script>
<script src="static/tour.js"></script>

</head>
<body>
	<div id="wrap">
		<div id="header">
			<div id="slidenum">1</div>
				<a href="#toc" id="tocbtn" title="Table of Contents"></a>
				<h1>Tour de Go</h1>
			</div>

			<div id="slides" class="slides"><!-- begin slides -->

<div class="slide">
	<h2>Hola, 世界</h2>
	<p>
	Benvingut/da al tour del
	<a target="_blank" href="http://golang.org/">llenguatge de programació Go</a>.
	<p>
	El tour està dividit en tres seccions. Al final de cada secció
	hi ha una sèrie d'exercicis que pots completar.
	<p>
	El tour és interactiu. Fes click al botó Executar (o tecleja
	Shift-Enter) per compilar i executar el programa a
	<span class="appengineMode">un servidor remot.</span>
	<span class="localMode">el teu ordinador.</span>
	El resultat es mostrarà sota el teu codi.
	<p>
	Els programes d'exemple mostren diferents aspectes de Go. Els
	programes del tour estan pensats per ser un punt de partida cap a la teva pròpia
	experimentació.
	<p>
	Edita el programa i executa'l de nou.
	<p>
	Sempre que estiguis preparat/da per continuar pressiona el botó Següent o la
	tecla PageDown (avançar pàgina).
<pre class="source">package main

import "fmt"

func main() {
	fmt.Println("Hola, 世界")
}</pre>
</div>

<div class="slide nocode appengineMode">
	<h2>Go local</h2>
	<p>
	El tour està disponible en altres llengües:
	<ul>
	<li><a href="http://tour.golang.org/">Anglès &mdash; English</a></li>
	<li><a href="http://go-tour-es.appspot.com/">Espanyol &mdash; Español</a></li>
	<li><a href="http://go-tour-he.appspot.com/">Hebreu &mdash; עִבְרִית</a></li>
	<li><a href="http://go-tour-jp.appspot.com/">Japonès &mdash; 日本語</a></li>
	<li><a href="http://go-tour-br.appspot.com/">Portuguès de Brasil &mdash; Português do Brasil</a></li>
	<li><a href="http://go-tour-zh.appspot.com/">Xinès &mdash; 普通话</a></li>
	</ul>
	<p>
	(Si desitges traduir el tour a un altre idioma, descarrega
	el codi de <code>https://code.google.com/p/go-tour</code>,
	tradueix <code>static/index.html</code> i penja'l a l'App
	Engine seguint les instruccions a <code>appengine/README</code>.)
	<p>
	Prem el botó "Següent" o la tecla PageDown per tal de continuar.
</div>

<div class="slide nocode appengineMode">
	<h2>Go sense connexió</h2>
	<p>
	Aquest tour també està disponible com a programa independent que pots usar
	sense accés a internet.
	<p>
	El tour independent és més ràpid ja que compila i executa els exemples de codi
	al teu propi ordinador. També inclou exercicis addicionals que no es troben
	en aquesta versió (en un sandbox). Però només està en anglès.
	<p>
	Per executar el tour localment primer
	<a target="_blank" href="http://golang.org/doc/install/">instal·la Go</a>,
	després
	<a target="_blank" href="http://golang.org/cmd/go/">executa "go get"</a> per instal·lar
	<a target="_blank" href="http://code.google.com/p/go-tour/">gotour</a>:
	<pre>go get code.google.com/p/go-tour/gotour</pre>
	<p>
	i executa l'executable de <code>gotour</code> resultant.
	<p>
	Si no, clicka el botó "Següent" o pressiona PageDown per continuar.
	<p>
	<i>(Pots tornar a aquestes instruccions sempre que vulguis prement
	el botó "Taula de continguts".)</i>
</div>

<div class="toc">Introducció</div>

<div class="slide">
	<h2>Paquets</h2>
	<p>
	Tot programa de Go està format per paquets.
	<p>
	Els programes comencen executant el paquet <code>main</code>.
	<p>
	Aquest programa utilitza els paquets amb ruta d'importació
	<code>"fmt"</code> i <code>"math"</code>.
	<p>
	Per convenció, el nom del paquet és el mateix que 
	l'últim element de la ruta d'importació.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println("Feliç", math.Pi, "Dia")
}</pre>
</div>

<div class="slide">
	<h2>Important paquets</h2>
	<p>
	Aquest codi agrupa la importació de paquets en una instrucció entre parèntesis, 
	"factoritzada". També pots escriure múltiples instruccions important paquets, com:
	<pre>import "fmt"
import "math"</pre>
	però és comú utilitzar la forma "factoritzada" per motius d'ordre.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Ara tens %g problemes.",
		math.Nextafter(2, 3))
}</pre>
</div>

<div class="slide">
	<h2>Noms exportats</h2>
	<p>
	Quan has importat un paquet pots referir-te als noms que aquest exporta.
	<p>
	A Go, un nom s'exporta si comença per majúscula.
	<p>
	<code>Foo</code> és un nom exportat, com també ho és <code>FOO</code>.
	El nom <code>foo</code> no s'exporta.
	<p>
	Executa el codi. Aleshores canvia <code>math.pi</code> per <code>math.Pi</code>
	i prova-ho de nou.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}</pre>
</div>

<div class="slide">
	<h2>Funcions</h2>
	<p>
	Una funció pot prendre zero o més arguments.
	<p>
	En aquest exemple, <code>suma</code> pren dos paràmetres del tipus <code>int</code>.
	<p>
	Nota que el tipus s'escriu <i>després</i> del nom de la variable.
	<p>
	(Per saber més sobre el motiu de pel qual els tipus es fan servir com ho fan, llegiu
	<a target="_blank" href="http://golang.org/doc/articles/gos_declaration_syntax.html">
	l'article "Go's declaration syntax"</a>.)
<pre class="source">package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}</pre>
</div>

<div class="slide">
	<h2>Funcions (continuació)</h2>
	<p>
	Quan dos o més paràmetres amb nom d'una funció comparteixen el tipus
	pots ometre'l per tots ells excepte l'últim.
	<p>
	En aquest exemple hem escurçat
	<pre>x int, y int</pre>
	<p>
	deixant-ho
	<pre>x, y int</pre>
<pre class="source">package main

import "fmt"

func add(x, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}</pre>
</div>

<div class="slide">
	<h2>Múltiples resultats</h2>
	<p>
	Una funció por tornar més d'un resultat.
	<p>
	Aquesta funció torna dues <code>string</code> (cadenes de caràcters).
<pre class="source">package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hola", "món")
	fmt.Println(a, b)
}</pre>
</div>

<div class="slide">
	<h2>Resultats amb nom</h2>
	<p>
	Les funcions prenen paràmetres. A Go, les funcions poden tornar més d'un
	"paràmetres resultat", no només un.
	Aquests poden tenir nom i actuar com variables.
	<p>
	Si els paràmetres resultat tenen nom, la instrucció <code>return</code>
	sense argument torna el valor actual de les variables que els representen.
<pre class="source">package main

import "fmt"

func split(total int) (x, y int) {
	x = total * 4/9
	y = total - x
	return
}

func main() {
	fmt.Println(split(17))
}</pre>
</div>

<div class="slide">
	<h2>Variables</h2>
	<p>
	La instrucció <code>var</code> declara una llista de variables.
	Com a la llista d'arguments d'una funció, el tipus va al final.

<pre class="source">package main

import "fmt"

var x, y, z int
var c, python, java bool

func main() {
	fmt.Println(x, y, z, c, python, java)
}</pre>
</div>

<div class="slide">
	<h2>Variables amb valor inicial</h2>
	<p>
	Una declaració <code>var</code> pot incloure valors inicials, un per cada variable.
	<p>
	Si un valor inicial és present el tipus es pot ometre,
	la variable prendrà el tipus del valor inicial.
<pre class="source">package main

import "fmt"

var x, y, z int = 1, 2, 3
var c, python, java = true, false, "no!"

func main() {
	fmt.Println(x, y, z, c, python, java)
}</pre>
</div>

<div class="slide">
	<h2>Declaració de variables implícita</h2>
	<p>
	En una funció, l'operand <code>:=</code> es pot fer servir enlloc
	de la declaració <code>var</code>. El tipus de la variable va implícit.
	<p>
	(Fora d'una funció cada instrucció comença amb una paraula clau i l'operand
	<code>:=</code> no està disponible.)
<pre class="source">package main

import "fmt"

func main() {
	var x, y, z int = 1, 2, 3
	c, python, java := true, false, "no!"

	fmt.Println(x, y, z, c, python, java)
}</pre>
</div>

<div class="slide">
	<h2>Constants</h2>
	<p>
	Les constants es declaren com les variables però amb la paraula clau
	<code>const</code>.
	<p>
	Una constant pot ser un caràcter, una string, un booleà o un valor numèric.
<pre class="source">package main

import "fmt"

const Pi = 3.14

func main() {
	const World = "世界"
	fmt.Println("Hola", World)
	fmt.Println("Feliç", Pi, "Dia")

	const Truth = true
	fmt.Println("Go mola?", Truth)
}</pre>
</div>

<div class="slide">
	<h2>Constants Numèriques</h2>
	<p>
	Les constants numèriques són <i>valors</i> d'alta precissió.
	<p>
	Una constant sense tipus definit pren el tipus del seu context.
	<p>
	Prova d'imprimir <code>needInt(Big)</code> també.
<pre class="source">package main

import "fmt"

const (
	Big = 1&lt;&lt;100
	Small = Big&gt;&gt;99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x*0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Go només té una instrucció per als bucles, l'operand <code>for</code>.
	<p>
	El <code>for</code> bàsic és com a C o Java,
	excepte que els <code>( )</code> desapareixen (no són ni opcionals)
	i els <code>{ }</code> són obligatoris.
<pre class="source">package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i &lt; 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}</pre>
</div>

<div class="slide">
	<h2>For (continuació)</h2>
	<p>
	Com a C o Java, pots deixar les instruccions inicial i d'increment buides.
<pre class="source">package main

import "fmt"

func main() {
	sum := 1
	for ; sum &lt; 1000; {
		sum += sum
	}
	fmt.Println(sum)
}</pre>
</div>

<div class="slide">
	<h2>For és el "while" de Go</h2>
	<p>
	Fent-ho així pots eliminar els punt i coma:
	El <code>while</code> de C s'escriu <code>for</code> a Go.
<pre class="source">package main

import "fmt"

func main() {
	sum := 1
	for sum &lt; 1000 {
		sum += sum
	}
	fmt.Println(sum)
}</pre>
</div>

<div class="slide">
	<h2>Etern</h2>
	<p>
	Si no inclous la condició de bucle esdevé un bucle infinit 
	de manera que un bucle infinit s'escriu de manera compacta.
<pre class="source">package main

func main() {
	for {
	}
}</pre>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	La instrucció <code>if</code> és similar a la de C o Java,
	excepte que els <code>( )</code> desapareixen (no són ni opcionals)
	i els <code>{ }</code> són obligatoris.
	<p>
	(Et recorda quelcom?)
<pre class="source">package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x &lt; 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}</pre>
</div>

<div class="slide">
	<h2>If amb instrucció inicial</h2>
	<p>
	Com el <code>for</code> la instrucció <code>if</code> pot començar amb
	una instrucció inicial abans de la condició.
	<p>
	Les variables declarades en aquesta instrucció només són visibles a l'àmbit de la
	instrucció <code>if</code>.
	<p>
	(Intenta usar <code>v</code> a la última instrucció <code>return</code>.)
<pre class="source">package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v &lt; lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}</pre>
</div>

<div class="slide">
	<h2>If i else</h2>
	<p>
	Les variables declarades dins d'una instrucció inicial d'un <code>if</code> 
	també són visibles a qualsevol dels seus blocs <code>else</code>.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v &lt; lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// no pots fer servir v aquí
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}</pre>
</div>

<div class="slide">
	<h2>Tipus bàsics</h2>
	<p>
	Els tipus bàsics de Go són
	<pre>bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // àlies per uint8

rune // àlies per int32
     // representa un codi Unicode

float32 float64

complex64 complex128</pre>
<pre class="source">package main

import (
	"math/cmplx"
	"fmt"
)

var (
	ToBe bool = false
	MaxInt uint64 = 1&lt;&lt;64 - 1
	z complex128 = cmplx.Sqrt(-5+12i)
)

func main() {
	const f = "%T(%v)\n"
	fmt.Printf(f, ToBe, ToBe)
	fmt.Printf(f, MaxInt, MaxInt)
	fmt.Printf(f, z, z)
}</pre>
</div>

<div class="slide">
	<h2>Estructures i tipus</h2>
	<p>
	Un <code>struct</code> és una estructura d'un conjunt de camps de dades.
	<p>
	(Una declaració <code>type</code> defineix un tipus per dades.)
<pre class="source">package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}</pre>
</div>

<div class="slide">
	<h2>Camps d'una estructura</h2>
	<p>
	Els camps d'una <code>struct</code> s'accedeixen mitjançant un punt.
<pre class="source">package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
}</pre>
</div>

<div class="slide">
	<h2>Punters</h2>
	<p>
	Go té punters (o apuntadors) però no permet aritmètica de punters.
	<p>
	Es pot accedir als camps d'una <code>struct</code> mitjançant un punter.
	L'accés al contingut a través del punter és transparent.
<pre class="source">package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	p := Vertex{1, 2}
	q := &amp;p
	q.X = 1e9
	fmt.Println(p)
}</pre>
</div>

<div class="slide">
	<h2>Literals d'estructures</h2>
	<p>
	Un literal d'estructura denota una nova instància d'una estructura
	creada llistant els valors dels seus camps.
	<p>
	Pots llistar només els valors d'un subconjunt de camps utilitzant la sintaxis
	<code>Camp:valor</code>. (L'ordre dels camps és irrellavant).
	<p>
	El prefix especial <code>&amp;</code> construeix punter a un
	literal d'estructura.
	<p>
	(<i><b>NdT:</b> Un literal és un valor fixat al codi font d'un programa</i>)
<pre class="source">package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	p = Vertex{1, 2}  // tipus Vertex
	q = &amp;Vertex{1, 2} // Tipus *Vertex (punter)
	r = Vertex{X: 1}  // Y:0 és implicit
	s = Vertex{}      // X:0 i Y:0
)

func main() {
	fmt.Println(p, q, r, s)
}</pre>
</div>

<div class="slide">
	<h2>Funció new</h2>
	<p>
	L'expressió <code>new(T)</code> reserva espai per un valor del tipus <code>T</code>
	inicialitzat i torna un punter a aquesta reserva.
	<pre>var t *T = new(T)</pre>
	<p>
	o
	<pre>t := new(T)</pre>
<pre class="source">package main

import "fmt"

type Vertex struct {
	X, Y int
}

func main() {
	v := new(Vertex)
	fmt.Println(v)
	v.X, v.Y = 11, 9
	fmt.Println(v)
}</pre>
</div>

<div class="slide">
	<h2>Map</h2>
	<p>
	El tipus <code>map</code> relaciona claus amb valors.
	<p>
	<!-- TODO: empty part not true in compilers yet -->
	Cal construir un <code>map</code> mitjançant <code>make</code> (i no <code>new</code>) 
	abans de ser utilitzat. El valor inicial (<code>nil</code>) d'un <code>map</code>
	és buit i no pot ser assignat.
<pre class="source">package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, -74.39967,
	}
	fmt.Println(m["Bell Labs"])
}</pre>
</div>

<div class="slide">
	<h2>Literals de map </h2>
	<p>
	Els literals de <code>map</code> són com els literals d'estructures
	però les claus són obligatòries.
<pre class="source">package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}</pre>
</div>

<div class="slide">
	<h2>Literals de map (continuació)</h2>
	<p>
	Si els elements del map tenen un tipus amb nom pots ometre'l 
	de cada element del literal.
<pre class="source">package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}</pre>
</div>

<div class="slide">
	<h2>Operacions amb map</h2>
	<p>
	Inserir o actualitzar un element d'un map <code>m</code>:
	<pre>m[clau] = elem</pre>
	<p>
	Recuperar un element:
	<pre>elem = m[clau]</pre>
	<p>
	Esborrar un element:
	<pre>delete(m, clau)</pre>
	<p>
	Comprovar si una clau és present amb una doble assignació:
	<pre>elem, ok = m[clau]</pre>
	<p>
	Si <code>clau</code> existeix a <code>m</code>,
	<code>ok</code> és <code>true</code>.
	Altrament <code>ok</code> és <code>false</code> i
	<code>elem</code> té el valor inicial (el "zero") del tipus dels 
	elements del map.
	<p>
	De manera semblant, quan llegim d'un map, si la clau no hi és
	el resultat és el valor inicial del tipus dels elements del map.
<pre class="source">package main

import "fmt"

func main() {
	m := make(map[string]int)

	m["Answer"] = 42
	fmt.Println("Valor:", m["Answer"])

	m["Answer"] = 48
	fmt.Println("Valor:", m["Answer"])

	delete(m, "Answer")
	fmt.Println("Valor:", m["Answer"])

	v, ok := m["Answer"]
	fmt.Println("Valor:", v, "Present?", ok)
}</pre>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	Una slice apunta a un vector de valors i inclou una grandària.
	<p>
	<code>[]T</code> és una slice amb elements del tipus <code>T</code>.
<pre class="source">package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)

	for i := 0; i &lt; len(p); i++ {
		fmt.Printf("p[%d] == %d\n",
			i, p[i])
	}
}</pre>
</div>

<div class="slide">
	<h2>Tallant llesques (Slicing slices)</h2>
	<p>
	Les slices es poden reassignar creant una nova 
	slice que apunta al mateix vector.
	<p>
	L'expressió
	<pre>s[lo:hi]</pre>
	<p>
	s'avalua com una slice amb els elements de <code>lo</code> fins
	<code>hi-1</code>, inclosos. Per tant
	<pre>s[lo:lo]</pre>
	<p>
	és buit i
	<pre>s[lo:lo+1]</pre>
	<p>
	té un element.
<pre class="source">package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)
	fmt.Println("p[1:4] ==", p[1:4])

	// Ometre l'índex inicial implica 0
	fmt.Println("p[:3] ==", p[:3])

	// Ometre l'índex final implica len(s)
	fmt.Println("p[4:] ==", p[4:])
}</pre>
</div>

<div class="slide">
	<h2>Creant slices</h2>
	<p>
	Les slices es creen amb la funció <code>make</code>. 
	Funciona reservant un vector de valors inicials (zeros) 
	i tornant una slice que hi apunta:
	<pre>a := make([]int, 5)  // len(a)=5</pre>
	Les slices tenen longitud i capacitat. La capacitat d'una slice
	és la longitud màxima que una slice pot créixer al vector subjacent.
	<p>
	Per especificar una capacitat pots passar un tercer argument 
	la funció <code>make</code>:
	<p>
	<pre>b := make([]int, 0, 5) // len(b)=0, cap(b)=5</pre>
	Les slices es poden reassignar (respectant la seva capacitat):
	<p>
	<pre>b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4</pre>
<pre class="source">package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)
	b := make([]int, 0, 5)
	printSlice("b", b)
	c := b[:2]
	printSlice("c", c)
	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}</pre>
</div>

<div class="slide">
	<h2>Slices nil</h2>
	<p>
	El valor inicial d'una slice és <code>nil</code>.
	<p>
	Una slice nil té longitud i capacitat 0.
	<p>
	(per aprendre més sobre slices, llegeix l'article en anglès 
	"<a target="_blank" href="http://golang.org/doc/articles/slices_usage_and_internals.html">Slices: usage and internals</a>"
	)
<pre class="source">package main

import "fmt"

func main() {
	var z []int
	fmt.Println(z, len(z), cap(z))
	if z == nil {
		fmt.Println("nil!")
	}
}</pre>
</div>

<div class="slide">
	<h2>Funcions són valors</h2>
	<p>
	Les funcions també són valors (poden assignar-se).
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}

	fmt.Println(hypot(3, 4))
}</pre>
</div>

<div class="slide">
	<h2>Funcions són clausures</h2>
	<p>
	I les funcions són clausures completes.
	<p>
	La funció <code>adder</code> torna una clausura.
	Cada clausura està vinculada a la seva pròpia variable <code>sum</code>.
<pre class="source">package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i &lt; 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}</pre>
</div>

<div class="slide">
	<h2>Range</h2>
	<p>
	L'operand <code>range</code> dels bucles <code>for</code>
	itera sobre els elements d'una slice o un map.
<pre class="source">package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
	    fmt.Printf("2**%d = %d\n", i, v)
	}
}</pre>
</div>

<div class="slide">
	<h2>Range (continuació)</h2>
	<p>
	Pots descartar l'índex o el valor assignant-lo a <code>_</code>.
	<p>
	Si només vols l'índex, descarta el
	&ldquo;<code>, valor</code>&rdquo; completament.
<pre class="source">package main

import "fmt"

func main() {
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1&lt;&lt;uint(i)
	}
	for _, valor := range pow {
		fmt.Printf("%d\n", valor)
	}
}</pre>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	Probablement ja sabies quina pinta tindria la instrucció <code>switch</code>.
	<p>
	El bloc d'un <code>case</code> surt automàticament del <code>switch</code> a no ser que acabi amb una instrucció <code>fallthrough</code>.

<pre class="source">package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go corrent sobre ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.", os)
	}
}</pre>
</div>

<div class="slide">
	<h2>Ordre d'avaluació switch</h2>
	<p>
	Els diferents <code>case</code> d'un <code>switch</code> s'avaluen de dalt a baix,
	aturant-se al primer cas satisfactori.
	<p>
	(Per exemple,
	<pre>switch i {
case 0:
case f():
}</pre>
	<p>
	no crida <code>f</code> si <code>i==0</code>.)

<p class="appengineMode">
Nota: El temps a Go playground sempre comença el dimarts 2009-11-10 23:00:00 UTC,
un valor amb significat es deixa com a exercici per al lector.

<pre class="source">package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("Quan és dissabte?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today+0:
		fmt.Println("Avui.")
	case today+1:
		fmt.Println("Demà.")
	case today+2:
		fmt.Println("En dos dies.")
	default:
		fmt.Println("Massa lluny.")
	}
}</pre>
</div>

<div class="slide">
	<h2>Switch sense condició</h2>
	<p>
	Un <code>switch</code> sense condició és el mateix que <code>switch true</code>.
	<p>
	Aquesta construcció pot ser una manera clara d'escriure cadenes llargues <code>if-then-else</code>.
<pre class="source">package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	switch {
	case t.Hour() &lt; 12:
	    fmt.Println("Bon dia!")
	case t.Hour() &lt; 17:
	    fmt.Println("Bona tarda.")
	default:
	    fmt.Println("Bon vespre.")
	}
}</pre>
</div>

<div class="slide">
	<h2>Exercici: Bucles i Funcions</h2>
	<p>
	Una manera simple de practicar amb les funcions i els bucles és implementar
	l'arrel quadrada fent servir el mètode de Newton-Raphson.
	<p>
	En aquest cas, el mètode de Newton és aproximar <code>Sqrt(x)</code>
	escollint un punt inicial <i>z</i> i iterant:
	<div style="text-align: center">
	<img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=z=z-\frac{z^2-x}{2z}" alt="Newton's method">
	</div>
	<p>
	Per començar, repeteix el càlcul 10 vegades i mira com t'aproximes a la
	solució de diferents valors (1, 2, 3, ...).
	<p>
	Després, pots canviar la condició de bucle per que s'aturi quan el càlcul
	no canvia més (o canvia un "delta" molt petit).
	Mira si són més o menys iteracions.
	
	Quant t'has aproximat al resultat de <a target="_blank" href="http://golang.org/pkg/math/#Sqrt">math.Sqrt</a>?
	<p>
	Pista: per declarar i inicialitzar un valor decimal flotant, dóna-li
	un valor decimal o fes servir una conversió:
	<pre>z := float64(1)
z := 1.0</pre>
	<p>
	Nota: guarda la teva funció que la farem servir més endavant.

<pre class="source">package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
}

func main() {
	fmt.Println(Sqrt(2))
}</pre>
</div>

<div class="slide">
	<h2>Exercici: Maps</h2>
	<p>
	Implementa <code>WordCount</code>.  Hauria de tornar un map que compti quantes
	vegades apareix cada &ldquo;paraula&rdquo; de la string <code>s</code>.
	La funció <code>wc.Test</code> executa un conjunt de tests fent servir la funció
	que implementis imprimint si ha anat bé (PASS) o malament (FAIL).
	<p>
	Pots trobar útil el mètode <a target="_blank" href="http://golang.org/pkg/strings/#Fields">strings.Fields</a>.

<pre class="source">package main

import (
	"<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/wc"
)

func WordCount(s string) map[string]int {
	return map[string]int{"x": 1}
}

func main() {
	wc.Test(WordCount)
}</pre>
</div>

<div class="slide">
	<h2>Exercici: Slices</h2>
	<p>
	Implementa <code>Pic</code>. Hauria de tornar una slice de longitud
	<code>dy</code> cada element del qual és una slice de <code>dx</code>
	enters sense signe de 8-bit (i.e. <code>[]uint8</code>). Quan executis el programa mostrarà
	el teu dibuix, interpretant els enters com valors d'una escala de grisos (de fet, de blaus).
	<p>
	L'elecció de l'imatge és tota teva.
	Algunes funcions interessants poden ser <code>x^y</code>, <code>(x+y)/2</code> o <code>x*y</code>.
	<p>
	(Necessites fes servir un bucle per reservar espai per a cada slide <code>[]uint8</code> dins
	la slide <code>[][]uint8</code>.)
	<p>
	(Fes servir <code>uint8(valorEnter)</code> per convertir els tipus.)

<pre class="source">package main

import "<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/pic"

func Pic(dx, dy int) [][]uint8 {
}

func main() {
	pic.Show(Pic)
}</pre>
</div>

<div class="slide">
	<h2>Exercici: Clausura de Fibonacci</h2>
	<p>
	Juguem una mica amb les funcions.
	<p>
	Implementa una funció <code>fibonacci</code> que torni una funció
	(clausura) que torni nombres de fibonacci successius.

<pre class="source">package main

import "fmt"

// fibonacci és una funció que torna
// una funció que torna un int.
func fibonacci() func() int {
}

func main() {
	f := fibonacci()
	for i := 0; i &lt; 10; i++ {
		fmt.Println(f())
	}
}</pre>
</div>

<div class="slide">
	<h2>Exercici avançat: Arrels cúbiques complexes</h2>
	<p>
	Investiguem el suport de Go per a nombres complexos mitjançant
	els tipus <code>complex64</code> i <code>complex128</code>.
	Per a arrels cúbiques, el mètode de Newton Raphson es basa en repetir:
	<div style="text-align: center">
	<img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=z=z-\frac{z^3-x}{3z^2}" alt="Newton's method">
	</div>
	<p>
	Troba l'arrel cúbica de 2 per assegurar-te que l'algoritme funciona.
	Hi ha una funció <a target="_blank" href="http://golang.org/pkg/math/cmplx/#Pow">Pow</a>
	al paquet <code>math/cmplx</code>.

<pre class="source">package main

import "fmt"

func Cbrt(x complex128) complex128 {
}

func main() {
	fmt.Println(Cbrt(2))
}</pre>
</div>


<div class="toc">Mètodes i Interfícies</div>

<div class="slide nocode">
<h2>Mètodes i interfícies</h2>
</div>

<div class="slide">
	<h2>Mètodes</h2>
	<p>
	Go no té classes. No obstant pots definir mètodes als tipus d'estructura.
	<p>
	El <i>receptor del mètode</i> apareix a la seva pròpia llista d'arguments
	entre la paraula clau <code>func</code> i el nom del mètode.
<pre class="source">package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &amp;Vertex{3, 4}
	fmt.Println(v.Abs())
}</pre>
</div>

<div class="slide">
	<h2>Mètodes (continuació)</h2>
	<p>
	De fet, pots definir un mètode sobre <i>qualsevol</i> tipus que defineixis
	al teu paquet, no només estructures.
	<p>
	No pots definir mètodes sobre tipus d'altres paquets, o sobre un tipus bàsic.
<pre class="source">package main

import (
	"fmt"
	"math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f &lt; 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}</pre>
</div>

<div class="slide">
	<h2>Mètodes amb punters als receptors</h2>
	<p>
	Els mètodes es poden associar amb un tipus amb nom o
	a un punter a un tipus amb nom.
	<p>
	Acabem de veure dos mètodes <code>Abs</code>. Un associat als 
	punters del tipus <code>*Vertex</code> i l'altre 
	associat al tipus <code>MyFloat</code>.
	<p>
	Hi ha dos motius per usar un punter com a receptor.
	Primer, per evitar copiar el valor a cada crida al mètode (més eficient
	si el valor té com a tipus una estructura gran). Segon, per tal que el
	mètode modifiqui el valor al qual apunta el receptor.
	<p>
	Prova de canviar les declaracions dels mètodes <code>Abs</code> i
	<code>Scale</code> per fer servir <code>Vertex</code> com
	a receptor enlloc de <code>*Vertex</code>.
	<p>
	El mètode <code>Scale</code> no té efecte quan <code>v</code> és un
	<code>Vertex</code>. <code>Scale</code> canvia <code>v</code>. Si
	<code>v</code> és un tipus valor (no punter) el mètode veu una còpia
	del <code>Vertex</code> i no pot modificar el valor original.
	<p>
	<code>Abs</code> funciona de qualsevol manera. Només llegeix <code>v</code>.
	No importa si llegeix el valor original (mitjançant un punter)
	o una còpia d'aquell valor.
<pre class="source">package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &amp;Vertex{3, 4}
	v.Scale(5)
	fmt.Println(v, v.Abs())
}</pre>
</div>

<div class="slide">
	<h2>Interfícies</h2>
	<p>
	Un tipus <code>interface</code> (interfície) es defineix declarant un conjunt de mètodes.
	<p>
	Una variable d'una <code>interface</code> pot contenir qualsevol variable amb un
	tipus que implementi els seus mètodes.

<pre class="source">package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // a és MyFloat, implementa Abser
	a = &amp;v // a és *Vertex, implementa Abser
	a = v  // a és Vertex, NO implementa Abser

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f &lt; 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}</pre>
</div>

<div class="slide">
	<h2>Les interfícies s'implementen implícitament</h2>
	<p>
	Un tipus implementa una <code>interface</code> implementant els seus mètodes.
	<p>
	<i>No hi ha una declaració explícita.</i>
	<p>
	Aquest fet desacobla la implementació dels paquets dels paquets que defineixen
	les interfícies: no depenen l'un de l'altre.
	<p>
	A més, això encoratja la definició precisa de interfícies, perquè
	no cal que trobis cada implementació i l'etiquetis amb el nou nom de
	la <code>interface</code>.
	<p>
	<a target="_blank" href="http://golang.org/pkg/io/">el paquet io</a> defineix <code>Reader</code> i <code>Writer</code>. Tu no ho has de fer.
<pre class="source">package main

import (
	"fmt"
	"os"
)

type Reader interface {
	Read(b []byte) (n int, err error)
}

type Writer interface {
	Write(b []byte) (n int, err error)
}

type ReadWriter interface {
	Reader
	Writer
}

func main() {
	var w Writer

	// os.Stdout implementa Writer
	w = os.Stdout

	fmt.Fprintf(w, "hola, writer\n")
}</pre>
</div>

<div class="slide">
	<h2>Errors</h2>
	<p>
	Un error és qualsevol cosa que es pugui descriure amb una <code>string</code> 
	d'error. La idea és implementar el mètode <code>Error</code>, l'únic mètode 
	que té la <code>interface</code> predefinida <code>error</code>. 
	Aquest mètode torna una <code>string</code>:
	<pre>type error interface {
	Error() string
}</pre>

	<p>
	Les diferents rutines per imprimir del paquet <code>fmt</code> automàticament saben
	com cridar el mètode quan se li demana imprimir un <code>error</code>.

<pre class="source">package main

import (
	"fmt"
	"time"
)

type MyError struct {
	When time.Time
	What string
}

func (e *MyError) Error() string {
	return fmt.Sprintf("A les %v, %s",
		e.When, e.What)
}

func run() error {
	return &amp;MyError{
		time.Now(),
		"ha fallat",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}</pre>
</div>

<div class="slide">
	<h2>Web servers</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/net/http/">El paquet http</a> atén peticions 
	HTTP usant qualsevol valor que implementi <code>http.Handler</code>:
	<pre>package http

type Handler interface {
	ServeHTTP(w ResponseWriter, r *Request)
}</pre>
	<p>
	En aquest exemple el tipus <code>Hello</code> implementa <code>http.Handler</code>.
	<p>
	<span class="localMode">
	Visita <a href="http://localhost:4000/" target="_blank">http://localhost:4000/</a> 
	per veure la salutació.
	</span>
	<span class="appengineMode">
	<b>Nota:</b> Aquest exemple no funcionarà a la versió web del tour. Pots provar d'executar 
	web servers <a target="_blank" href="http://golang.org/doc/install/">instal·lant Go</a>.
	</span>
<pre class="source">package main

import (
	"fmt"
	"net/http"
)

type Hello struct{}

func (h Hello) ServeHTTP(
		w http.ResponseWriter,
		r *http.Request) {
	fmt.Fprint(w, "Hola!")
}

func main() {
	var h Hello
	http.ListenAndServe("localhost:4000",h)
}</pre>
</div>

<div class="slide">
	<h2>Imatges</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/image/#Image">El Paquet image</a> 
	defineix la <code>interface</code> (interfície) <code>Image</code>
	<pre>package image

type Image interface {
	ColorModel() color.Model
	Bounds() Rectangle
	At(x, y int) color.Color
}</pre>
	<p>
	(Visita <a target="_blank" href="http://golang.org/pkg/image/#Image">la
	documentació</a> per tenir més detalls.)
	<p>
	A més, <code>color.Color</code> i <code>color.Model</code> també són interfícies
	però les ignorarem utilitzant les implementacions predefinides
	<code>color.RGBA</code> i <code>color.RGBAModel</code>.

<pre class="source">package main

import (
	"fmt"
	"image"
)

func main() {
	m := image.NewRGBA(image.Rect(0, 0, 100, 100))
	fmt.Println(m.Bounds())
	fmt.Println(m.At(0, 0).RGBA())
}</pre>
</div>

<div class="slide">
	<h2>Exercici: Errors</h2>
	<p>
	Copia la teva funció <code>Sqrt</code> dels exercicis anteriors i modifica-la 
	per que torni un valor del tipus <code>error</code> (et vam avisar).
	<p>
	<code>Sqrt</code> hauria de tornar un error diferent de <code>nil</code> quan
	se li passa un nombre negatiu ja que no suporta nombres complexos.
	<p>
	Crea el nou tipus
	<pre>type ErrNegativeSqrt float64</pre>
	<p>
	i fes que sigui del tipus <code>error</code> implementant la funció
	<pre>func (e ErrNegativeSqrt) Error() string</pre>
	<p>
	de manera que <code>ErrNegativeSqrt(-2).Error()</code> torni
	<code>"No es pot passar un negatiu a Sqrt: -2"</code>.
	<p>
	<b>Nota:</b> cridar a <code>fmt.Sprint(e)</code> dins del mètode
	<code>Error</code> farà que el programa entri a un bucle infinit.
	Ho pots evitar fent primer la conversió de <code>e</code> a decimal:
	<code>fmt.Sprint(float64(e))</code>. Saps per què? 
	<!--TODO: Sprint o Print?-->
	<p>
	Canvia la teva funció <code>Sqrt</code> per tornar un valor
	<code>ErrNegativeSqrt</code> quan rebi un nombre negatiu.
<pre class="source">package main

import (
	"fmt"
)

func Sqrt(f float64) (float64, error) {
	return 0, nil
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}</pre>
</div>

<div class="slide localMode">
	<h2>Exercici: HTTP Handlers</h2>
	<p>
	Implementa els següents tipus i defineix-hi els mètodes ServeHTTP.
	Registra'ls per tractar unes direccions específiques del web server.
<pre>type String string

type Struct struct {
	Greeting string
	Punct    string
	Who      string
}</pre>
	<p>
	Per exemple, hauries de ser capaç de registrar manegadors (handlers) així:
	For example, you should be able to register handlers using:
<pre>http.Handle("/string", String("Sóc un nus esfilagarsat."))
http.Handle("/struct", &amp;Struct{"Hola", ":", "Gosquirols!"})</pre>
<pre class="source">package main

import (
	"net/http"
)

func main() {
	// Les teves crides a http.Handle van aquí
	http.ListenAndServe("localhost:4000", nil)
}</pre>
</div>

<div class="slide">
	<h2>Exercici: Imatges</h2>
	<p>
	Recordes el generador d'imatges que ja has programat?
	Anem a escriure'n un altre, però aquest cop tornarà una implementació
	de <code>image.Image</code> enlloc d'una slice.
	<p>
	Defineix el teu propi tipus <code>Image</code>, implementa
	<a href="http://golang.org/pkg/image/#Image" target="_blank">els mètodes necessaris</a>,
	i crida el mètode <code>pic.ShowImage</code>.
	<p>
	<code>Bounds</code> hauria de tornar un <code>image.Rectangle</code>, per exemple
	<code>image.Rect(0, 0, ample, alt)</code>.
	<p>
	<code>ColorModel</code> hauria de tornar <code>color.RGBAModel</code>.
	<p>
	<code>At</code> ha de tornar un color. El valor <code>v</code> a l'anterior generador
	d'imatges (escala de blaus) correspon a <code>color.RGBA{v, v, 255, 255}</code> en aquest exercici.

<pre class="source">package main

import (
	"image"
	"<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/pic"
)

type Image struct{}

func main() {
	m := Image{}
	pic.ShowImage(m)
}</pre>
</div>

<div class="slide">
	<h2>Exercici: Rot13 Reader</h2>
	<p>
	Un patró força comú és una implementació 
	d'<a target="_blank" href="http://golang.org/pkg/io/#Reader">io.Reader</a> que encapsula un altre
	<code>io.Reader</code>, modificant el flux de dades d'alguna manera.
	<p>
	Per exemple, la funció
	<a target="_blank" href="http://golang.org/pkg/compress/gzip/#NewReader">gzip.NewReader</a>
	pren un <code>io.Reader</code> (un flux de dades comprimit amb <code>gzip</code>)
	i torna un <code>*gzip.Reader</code> que implementa
	<code>io.Reader</code> (el flux de dades descomprimit).
	<p>
	Implementa el tipus <code>rot13Reader</code> que implementi
	<code>io.Reader</code> i llegeixi de <code>io.Reader</code>,
	aplicant al flux de dades l'algoritme de xifrat 
	<a target="_blank" href="http://en.wikipedia.org/wiki/ROT13">ROT13</a>
	a tots els caràcters alfabètics.
	<p>
	Et donem el tipus <code>rot13Reader</code>. Fes-lo un <code>io.Reader</code> 
	implementant el seu mètode <code>Read</code>.
<pre class="source">package main

import (
	"io"
	"os"
	"strings"
)

type rot13Reader struct {
	r io.Reader
}

func main() {
	s := strings.NewReader(
		"Unf qrfkvseng ry pbqv!") 
		//Lbh penpxrq gur pbqr!
	r := rot13Reader{s}
	io.Copy(os.Stdout, &amp;r)
}</pre>
</div>

<div class="toc">Concurrència</div>

<div class="slide nocode">
<h2>Concurrència</h2>
</div>

<div class="slide">
	<h2>Gorutines</h2>
	<p>
	Una <i>gorutina</i> és un fil d'execució lleuger que Go gestiona dinàmicament.
	<pre>go f(x, y, z)</pre>
	<p>
	crida una nova gorutina que comença a executar el mètode
	<pre>f(x, y, z)</pre>
	<p>
	L'avaluació de <code>f</code>, <code>x</code>, <code>y</code> i <code>z</code>
	succeeix a la rutina que fa la crida i l'execució de <code>f</code>
	succeeix a la nova gorutina.
	<p>
	Les gorutines corren al mateix espai d'adreces de manera que la memòria compartida
	ha de ser sincronitzada. El paquet <code><a href="http://golang.org/pkg/sync/"
	target="_blank">sync</a></code> conté primitives útils tot i que no les 
	necessitaràs massa a ja que go ja té unes altres. (Veure la següent diapositiva.)
<pre class="source">package main

import (
	"fmt"
	"<span class="appengineMode">runtime</span><span class="localMode">time</span>"
)

func say(s string) {
	for i := 0; i &lt; 5; i++ {
		<span class="appengineMode">runtime.Gosched()</span><span class="localMode">time.Sleep(100 * time.Millisecond)</span>
		fmt.Println(s)
	}
}

func main() {
	go say("món")
	say("hola")
}</pre>
</div>

<div class="slide">
	<h2>Canals</h2>

	<p>
	Els canals són un tipus de dades a través dels quals pots enviar i rebre valors amb 
	l'operador <code>&lt;-</code>.
<pre>ch &lt;- v    // Envia v al canal ch.
v := &lt;-ch  // Rep del canal ch, i
           // assigna el valor a v.</pre>
	<p>
	(El flux de dades va en el sentit de la fletxa.)

	<p>
	Com els <code>map</code> i <code>slice</code>, els canals han de ser creats abans de ser utilitzats:
<pre>ch := make(chan int)</pre>

	<p>
	Per defecte, fins que tant qui rep com qui envia estan llestos les operacions 
	d'enviar i rebre queden bloquejades.
	Això permet a les goroutines que es sincronitzin sense bloqueigs explícits o
	variables de condició.
<pre class="source">package main

import "fmt"

func sum(a []int, c chan int) {
	sum := 0
	for _, v := range a {
		sum += v
	}
	c &lt;- sum  // envia sum al canal c
}

func main() {
	a := []int{	7, 2, 8, -9, 4, 0}

	c := make(chan int)
	go sum(a[:len(a)/2], c)
	go sum(a[len(a)/2:], c)
	x, y := &lt;-c, &lt;-c  // rep del canal c

	fmt.Println(x, y, x + y)
}</pre>
</div>


<div class="slide">
	<h2>Canals amb buffer</h2>

	<p>
	Els canals poden tenir un <i>buffer</i>. Pots passar la mida del <i>buffer</i> com
	segon argument a <code>make</code> per inicialitzar un canal amb <i>buffer</i>:
<pre>ch := make(chan int, 100)</pre>

	<p>
	Només es bloqueja al enviar dades a un canal quan el <i>buffer</i> està ple.
	Al rebre es bloqueja quan el <i>buffer</i> és buit

	<p>
	Modifica l'exemple per saturar el <i>buffer</i> i observa el que passa.

<pre class="source">package main

import "fmt"

func main() {
	c := make(chan int, 2)
	c &lt;- 1
	c &lt;- 2
	fmt.Println(&lt;-c)
	fmt.Println(&lt;-c)
}</pre>
</div>

<div class="slide">
	<h2>Range i Close</h2>
	<p>
	L'emissor pot tancar un canal (<code>close</code>) per indicar que no s'enviaran 
	més dades. Els receptors poden comprovar si un canal és tancat
	assignant un segon paràmetre a la instrucció de recepció:
	<pre>v, ok := &lt;-ch</pre>
	<p>
	<code>ok</code> és <code>false</code> si no hi ha més valors per rebre
	i el canal és tancat.
	<p>
	El bucle <code>for i := range c</code> rep valors del canal <code>c</code> de manera
	reiterada fins que <code>c</code> és tancat (amb <code>close</code>).
	<p>
	<b>Nota:</b> Només l'emissor hauria de tancar el canal, mai el receptor.
	Enviar dades a un canal tancat causa un error <i>panic</i>.
	<p>
	<b>Nota2:</b> Els canals no són com fitxers, generalment no cal tancar-los.
	Tancar un canal només és necessari quan cal avisar al receptor de que no
	hi haurà més valors, per exemple, per finalitzar un bucle <code>range</code>.
<pre class="source">package main

import (
	"fmt"
)

func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i &lt; n; i++ {
		c &lt;- x
		x, y = y, x + y
	}
	close(c)
}

func main() {
	c := make(chan int, 10)
	go fibonacci(cap(c), c)
	for i := range c {
		fmt.Println(i)
	}
}</pre>
</div>

<div class="slide">
	<h2>Select</h2>
	<p>
	La instrucció <code>select</code> permet a una gorutina esperar més d'una
	operació de comunicació (via canals).
	<p>
	El <code>select</code> es bloqueja fins que un dels seus casos (<code>case</code>)
	pot continuar l'execució, aleshores executa aquell cas.
	En el cas que hi hagi més d'un cas disponible en tria un aleatòriament.
<pre class="source">package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c &lt;- x:
			x, y = y, x + y
		case &lt;-quit:
			fmt.Println("Sortir")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)	
	go func() {
		for i := 0; i &lt; 10; i++ {
			fmt.Println(&lt;-c)
		}
		quit &lt;- 0
	}()
	fibonacci(c, quit)
}</pre>
</div>

<div class="slide">
	<h2>Select per defecte</h2>
	<p>
	El cas <code>default</code> a un <code>select</code> s'executa si 
	no hi ha cap altre cas disponible.
	<p>
	Es pot fer servir el cas <code>default</code> per intentar enviar o rebre
	dades sense bloquejar la rutina:
	<pre>select {
case i := &lt;-c:
	// fa servir i
default:
	// rebre de c bloquejaria
}</pre>
	<p>
	<span class="appengineMode">
	<b>Nota:</b> Aquest exemple no funciona a la versió web del tour
	ja que l'entorn de prova (sandbox) no té el concepte de temps. Podries
	<a target="_blank" href="http://golang.org/doc/install/">instal·lar Go</a>
	per veure aquest exemple funcionant.
	</span>
<pre class="source">package main

import (
	"fmt"
	"time"
)

func main() {
	tick := time.Tick(1e8)
	boom := time.After(5e8)
	for {
		select {
		case &lt;-tick:
			fmt.Println("tick.")
		case &lt;-boom:
			fmt.Println("BOOM!")
			return
		default:
			fmt.Println("    .")
			time.Sleep(5e7)
		}
	}
	}</pre>
</div>

<div class="slide nocode">
	<h2>Exercici: Arbres binaris equivalents</h2>
	<p>
	Hi ha molts arbres binaris diferents que contenen la mateixa seqüència
	de valors emmagatzemats a les seves fulles.
	Per exemple, aquí pots veure dos arbres binaris que contenen la seqüència
	1, 1, 2, 3, 5, 8, 13.
	<img src="static/fig4.png" alt="binary trees">
	<p>
	Una funció per comprovar si dos arbres binaris contenen la mateixa seqüència
	és complex en molts llenguatges. Farem servir la concurrència i els canals de Go 
	per escriure una solució molt simple.
	<p>
	Aquest exemple fa servir el paquet <code>tree</code>, que defineix el tipus:
<pre>type Tree struct {
	Left  *Tree
	Value int
	Right *Tree
}</pre>
</div>

<div class="slide">
	<h2>Exercici: Arbres binaris equivalents</h2>
	<p>
	<b>1.</b> Implementa la funció <code>Walk</code>.
	<p>
	<b>2.</b> Prova la funció <code>Walk</code>.
	<p>
	La funció <code>tree.New(k)</code> construeix un arbre binari amb una estructura aleatòria
	contenint els valors <code>k</code>, <code>2k</code>, <code>3k</code>, ...,
	<code>10k</code>.
	<p>
	Crea un nou canal <code>ch</code> i engega el <i>walker</i>:
	<pre>go Walk(tree.New(1), ch)</pre>
	<p>
	Aleshores llegeix i escriu 10 valors del canal.
	Haurien de ser els nombres 1, 2, 3, ..., 10.
	<p>
	<b>3.</b> Implementa la funció <code>Same</code> fent servir <code>Walk</code>
	per determinar si <code>t1</code> i <code>t2</code> emmagatzemen els mateixos valors.
	<p>
	<b>4.</b> Prova la funció <code>Same</code>.
	<p>
	<code>Same(tree.New(1), tree.New(1))</code> hauria de tornar <code>true</code> i
	<code>Same(tree.New(1), tree.New(2))</code> hauria de tornar <code>false</code>.

<pre class="source">package main

import "<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/tree"

// Walk repassa l'arbre t enviant tots els valors
// de l'arbre al canal ch.
func Walk(t *tree.Tree, ch chan int)

// Same determina si els arbres
// t1 i t2 contenen els mateixos valors.
func Same(t1, t2 *tree.Tree) bool

func main() {
}</pre>
</div>

<div class="slide">
	<h2>Exercici: Web Crawler</h2>
	<p>
	En aquest exercici faràs servir les característiques de
	concurrència de Go per paral·lelitzar una aranya web (Web Crawler).
	<p>
	Modifica la funció <code>Crawl</code> per obtenir en paral·lel les URLs
	sense obtenir dues vegades la mateixa URL.
<pre class="source">package main

import (
	"fmt"
)

type Fetcher interface {
	// Fetch torna el body de la URL i
	// una slice de URLs trobades en aquesta pàgina.
	Fetch(url string) (body string, urls []string, err error)
}

// Crawl fa servir Fetcher per analitzar recursivament
// les pàgines que comencin per la url fins a nivell depth
func Crawl(url string, depth int, fetcher Fetcher) {
	// TODO: Obtenir URLs in paral·lel.
	// TODO: No recollir dos cops la mateixa URL.
	// Aquesta implementació no fa cap de les dues:
	if depth &lt;= 0 {
		return
	}
	body, urls, err := fetcher.Fetch(url)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("found: %s %q\n", url, body)
	for _, u := range urls {
		Crawl(u, depth-1, fetcher)
	}
	return
}

func main() {
	Crawl("http://golang.org/", 4, fetcher)
}


// fakeFetcher és un Fetcher que torna resultats repetits.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
	body string
	urls     []string
}

func (f *fakeFetcher) Fetch(url string) (string, []string, error) {
	if res, ok := (*f)[url]; ok {
		return res.body, res.urls, nil
	}
	return "", nil, fmt.Errorf("no es troba: %s", url)
}

// fetcher és un fakeFetcher ja omplert.
var fetcher = &amp;fakeFetcher{
	"http://golang.org/": &amp;fakeResult{
		"The Go Programming Language",
		[]string{
			"http://golang.org/pkg/",
			"http://golang.org/cmd/",
		},
	},
	"http://golang.org/pkg/": &amp;fakeResult{
		"Packages",
		[]string{
			"http://golang.org/",
			"http://golang.org/cmd/",
			"http://golang.org/pkg/fmt/",
			"http://golang.org/pkg/os/",
		},
	},
	"http://golang.org/pkg/fmt/": &amp;fakeResult{
		"Package fmt",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
	"http://golang.org/pkg/os/": &amp;fakeResult{
		"Package os",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
}</pre>
</div>

<div class="slide nocode">
	<h2>I ara? (Where to Go from here...)</h2>
	<p class="appengineMode">
	Pots començar
	<a href="http://golang.org/doc/install/">instal·lant Go</a> o descarregant el
	<a href="http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go">Go App Engine SDK</a>.
	</p>
	<p>
	<span class="appengineMode">Un cop tinguis Go al teu ordinador, la</span>
	<span class="localMode">La</span>
	<a target="_blank" href="http://golang.org/doc/">documentació de Go</a> és un gran lloc per
	<span class="appengineMode">continuar</span>
	<span class="localMode">començar</span>.
	Conté referències, tutorials, vídeos, i més.
	</p>
	<p>
	Per aprendre com organitzar i treballar amb codi Go, mira
	<a href="http://www.youtube.com/watch?v=XCsL89YtqCs">aquest screencast</a> 
	o llegeix <a href="http://golang.org/doc/code.html">Com escriure codi Go</a>.
	</p>
	<p>
	Si necessites ajuda amb les llibreries estàndard mira la 
	<a target="_blank" href="http://golang.org/pkg/">referència de paquets</a>.
	Per ajuda amb el llenguatge mateix, et sorprendrà que
	l'<a target="_blank" href="http://golang.org/ref/spec">especificació del Llenguatge</a> 
	no és complicada de llegir.
	</p>
	<p>
	Per obtenir més detalls del model de concurrència de Go, mira la revisió de codi
	<a target="_blank" href="http://golang.org/doc/codewalk/sharemem/">Comunicar per compartir memòria</a>.
	<p>
	La revisió de codi
	<a target="_blank" href="http://golang.org/doc/codewalk/functions/">Funcions de primera classe a Go</a>
	dóna una interessant perspectiva sobre els tipus que tenen les funcions a Go.
	<p>
	El <a target="_blank" href="http://blog.golang.org/">Bloc de Go</a> té un gran arxiu d'articles
	informatius sobre Go.
	<p>
	Visita <a target="_blank" href="http://golang.org">golang.org</a> per més informació.
</div>

</div><!-- end slides -->

<div id="workspace">
	<div class="controls">
		<div><a id="run" href="#run" title="Compile and Run">Run</a><a href="#more" id="more" title="Options">▼</a></div>
		<ul class="more">
			<li><a href="#" id="reset">Reset Slide</a></li>
			<li><a href="#" id="format">Format Source Code</a></li>
			<li><a href="#" id="kill" class="localMode">Kill Program</a></li>
			<li><hr></li>
			<li><a href="#" id="togglesyntax">Syntax-Highlighting: off</a></li>
			<li><a href="#" id="togglelineno">Line-Numbers: on</a></li>
		</ul>
	</div>

	<div id="workspace-top">
		<div id="workspace-editor">
			<textarea id="editor" spellcheck="false"></textarea>
		</div>
	</div>

	<div id="workspace-bottom">
		<div id="output"></div>
	</div>
</div>
</div>

</body>
</html>
